<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>esnext/lib/safeps.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/safeps.html">safeps</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: esnext/lib/safeps.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* eslint no-sync:0 */
&#x27;use strict&#x27;

// Import
const TaskGroup = require(&#x27;taskgroup&#x27;)
const typeChecker = require(&#x27;typechecker&#x27;)
const safefs = require(&#x27;safefs&#x27;)
const fsUtil = require(&#x27;fs&#x27;)
const pathUtil = require(&#x27;path&#x27;)
const extractOptsAndCallback = require(&#x27;extract-opts&#x27;)

// Prepare
const isWindows = (process.platform || &#x27;&#x27;).indexOf(&#x27;win&#x27;) === 0
const DEFAULT_MAX_OPEN_PROCESSES = 100


// =====================================
// Define Globals

// Prepare
if ( global.safepsGlobal == null ) {
	global.safepsGlobal = {}
}

// Define Global Pool
// Create a pool with the concurrency of our max number of open processes
if ( global.safepsGlobal.pool == null ) {
	global.safepsGlobal.pool = new TaskGroup().setConfig({
		concurrency: process.env.NODE_MAX_OPEN_PROCESSES == null ? DEFAULT_MAX_OPEN_PROCESSES : process.env.NODE_MAX_OPEN_PROCESSES,
		pauseOnError: false
	}).run()
}


// =====================================
// Define Module

/**
* Contains methods to safely spawn and manage
* various file system processes. It differs
* from the standard node.js child_process
* (https://nodejs.org/docs/v0.11.13/api/child_process.html#child_process_child_process)
* module in that it intercepts and handles
* many common errors that might occur when
* invoking child processes that could cause
* an application to crash. Most commonly, errors
* such as ENOENT and EACCESS. This enables
* an application to be both cleaner and more robust.
* @class safeps
* @static
*/
const safeps = {

	// =====================================
	// Open and Close Processes

	/**
	* Open a file.
	* Pass your callback to fire when it is safe to open the process
	* @method openProcess
	* @param {Function} fn callback
	*/
	openProcess (fn) {
		// Add the task to the pool and execute it right away
		global.safepsGlobal.pool.addTask(fn)

		// Chain
		return safeps
	},


	// =================================
	// Environments
	// @TODO These should be abstracted out into their own packages

	/**
	* Returns whether or not we are running on a windows machine
	* @method isWindows
	* @return {Boolean}
	*/
	isWindows () {
		return isWindows
	},

	/**
	* Get locale code - eg: en-AU,
	* fr-FR, zh-CN etc.
	* @method getLocaleCode
	* @param {String} lang
	* @return {String}
	*/
	getLocaleCode (lang) {
		lang = lang || process.env.LANG || &#x27;&#x27;
		const localeCode = lang.replace(/\..+/, &#x27;&#x27;).replace(&#x27;-&#x27;, &#x27;_&#x27;).toLowerCase() || null
		return localeCode
	},

	/**
	* Given the localeCode, return
	* the language code.
	* @method getLanguageCode
	* @param {String} localeCode
	* @return {String}
	*/
	getLanguageCode (localeCode) {
		localeCode = safeps.getLocaleCode(localeCode) || &#x27;&#x27;
		const languageCode = localeCode.replace(/^([a-z]+)[_-]([a-z]+)$/i, &#x27;$1&#x27;).toLowerCase() || null
		return languageCode
	},

	/**
	* Given the localeCode, return
	* the country code.
	* @method getCountryCode
	* @param {String} localeCode
	* @return {String}
	*/
	getCountryCode (localeCode) {
		localeCode = safeps.getLocaleCode(localeCode) || &#x27;&#x27;
		const countryCode = localeCode.replace(/^([a-z]+)[_-]([a-z]+)$/i, &#x27;$2&#x27;).toLowerCase() || null
		return countryCode
	},


	// =================================
	// Executeable Helpers

	/**
	* Has spawn sync. Returns true
	* if the child_process spawnSync
	* method exists, otherwise false
	* @method hasSpawnSync
	* @return {Boolean}
	*/
	hasSpawnSync () {
		return require(&#x27;child_process&#x27;).spawnSync != null
	},

	/**
	* Has exec sync. Returns true
	* if the child_process execSync
	* method exists, otherwise false
	* @method hasExecSync
	* @return {Boolean}
	*/
	hasExecSync () {
		return require(&#x27;child_process&#x27;).execSync != null
	},

	/**
	* Is the path to a file object an executable?
	* Boolean result returned as the isExecutable parameter
	* of the passed callback.
	* next(err, isExecutable)
	* @method isExecutable
	* @param {String} path path to test
	* @param {Object} [opts]
	* @param {Boolean} [opts.sync] true to test sync rather than async
	* @param {Function} next callback
	* @param {Error} next.err
	* @param {Boolean} next.isExecutable
	* @return {Boolean} returned if opts.sync = true
	*/
	isExecutable (path, opts, next) {
		// Prepare
		[opts, next] = extractOptsAndCallback(opts, next)

		// Sync?
		if ( opts.sync ) {
			return safeps.isExecutableSync(path, opts, next)
		}

		// Access (Node 0.12+)
		if ( fsUtil.access ) {
			fsUtil.access(path, fsUtil.X_OK, function (err) {
				const isExecutable = !err
				return next(null, isExecutable)
			})
		}

		// Shim
		else {
			require(&#x27;child_process&#x27;).exec(path + &#x27; --version&#x27;, function (err) {
				// If there was no error, then execution worked fine, so we are executable
				if ( !err )  return next(null, true)
				// If there was an error
				// determine if it was an error with trying to run it (not executable)
				// or an error from running it (executable)
				const isExecutable = err.code !== 127 &amp;&amp; (/EACCESS|Permission denied/).test(err.message) === false
				return next(null, isExecutable)
			})
		}

		// Chain
		return safeps
	},

	/**
	* Is the path to a file object an executable?
	* Synchronised version of isExecutable
	* @method isExecutableSync
	* @param {String} path path to test
	* @param {Object} opts
	* @param {Function} [next]
	* @param {Error} next.err
	* @param {Boolean} next.isExecutable
	* @return {Boolean}
	*/
	isExecutableSync (path, opts, next) {
		// Prepare
		let isExecutable

		// Access (Node 0.12+)
		if ( fsUtil.accessSync ) {
			try {
				fsUtil.accessSync(path, fsUtil.X_OK)
				isExecutable = true
			}
			catch ( err ) {
				isExecutable = false
			}
		}

		// Shim
		else {
			try {
				require(&#x27;child_process&#x27;).execSync(path + &#x27; --version&#x27;)
				isExecutable = true
			}
			catch ( err ) {
				// If there was an error
				// determine if it was an error with trying to run it (not executable)
				// or an error from running it (executable)
				isExecutable = err.code !== 127 &amp;&amp; (/EACCESS|Permission denied/).test(err.message) === false
			}
		}

		// Return
		if ( next ) {
			next(null, isExecutable)
			return safeps
		}
		else {
			return isExecutable
		}
	},

	/**
	* Internal: Prepare options for an execution.
	* Makes sure all options are populated or exist and
	* gives the opportunity to prepopulate some of those
	* options.
	* @private
	* @method prepareExecutableOptions
	* @param {Object} [opts]
	* @param {Stream} [opts.stdin=null] in stream
	* @param {Array} [opts.stdio=null] Child&#x27;s stdio configuration
	* @param {Boolean} [opts.safe=true]
	* @param {Object} [opts.env=process.env]
	* @return {Object} opts
	*/
	prepareExecutableOptions (opts) {
		// Prepare
		opts = opts || {}

		// Ensure all options exist
		if ( typeof opts.stdin === &#x27;undefined&#x27; )  opts.stdin = null
		if ( typeof opts.stdio === &#x27;undefined&#x27; )  opts.stdio = null

		// By default make sure execution is valid
		if ( opts.safe == null )   opts.safe = true

		// If a direct pipe then don&#x27;t do output modifiers
		if ( opts.stdio ) {
			opts.read = opts.output = false
			opts.outputPrefix = null
		}

		// Otherwise, set output modifiers
		else {
			if ( opts.read == null )          opts.read = true
			if ( opts.output == null )        opts.output = Boolean(opts.outputPrefix)
			if ( opts.outputPrefix == null )  opts.outputPrefix = null
		}

		// By default inherit environment variables
		if ( opts.env == null ) {
			opts.env = process.env
		}
		// If we don&#x27;t want to inherit environment variables, then don&#x27;t
		else if ( opts.env === false ) {
			opts.env = null
		}

		// Return
		return opts
	},

	/**
	* Internal: Prepare result of an execution
	* @private
	* @method updateExecutableResult
	* @param {Object} result
	* @param {Object} result.pid  Number Pid of the child process
	* @param {Object} result.output output Array Array of results from stdio output
	* @param {Stream} result.stdout stdout The contents of output
	* @param {Stream} result.stderr stderr The contents of output
	* @param {Number} result.status status The exit code of the child process
	* @param {String} result.signal signal The signal used to kill the child process
	* @param {Error} result.error The error object if the child process failed or timed out
	* @param {Object} [opts]
	* @param {Object} [opts.output]
	* @param {Object} [opts.outputPrefix]
	* @return {Object} result
	*/
	updateExecutableResult (result, opts) {
		// If we want to output, then output the correct streams with the correct prefixes
		if ( opts.output ) {
			safeps.outputData(result.stdout, &#x27;stdout&#x27;, opts.outputPrefix)
			safeps.outputData(result.stderr, &#x27;stderr&#x27;, opts.outputPrefix)
		}

		// If we already have an error, then don&#x27;t continue
		if ( result.error ) {
			return result
		}

		// We don&#x27;t already have an error, so let&#x27;s check the status code for an error
		// Check if the status code exists, and if it is not zero, zero is the success code
		if ( result.status != null &amp;&amp; result.status !== 0 ) {
			let message = &#x27;Command exited with a non-zero status code.&#x27;

			// As there won&#x27;t be that much information on this error, as it was not already provided
			// we should output the stdout if we have it
			if ( result.stdout ) {
				const tmp = safeps.prefixData(result.stdout)
				if ( tmp ) {
					message += &quot;\nThe command&#x27;s stdout output:\n&quot; + tmp
				}
			}
			// and output the stderr if we have it
			if ( result.stderr ) {
				const tmp = safeps.prefixData(result.stderr)
				if ( tmp ) {
					message += &quot;\nThe command&#x27;s stderr output:\n&quot; + tmp
				}
			}

			// and create the error from that output
			result.error = new Error(message)
			return result
		}

		// Success
		return result
	},


	/**
	* Internal: prefix data
	* @private
	* @method prefixData
	* @param {Object} data
	* @param {String} [prefix = &#x27;&gt;\t&#x27;]
	* @return {Object} data
	*/
	prefixData (data, prefix = &#x27;&gt;\t&#x27;) {
		data = data &amp;&amp; data.toString &amp;&amp; data.toString() || &#x27;&#x27;
		if ( prefix &amp;&amp; data ) {
			data = prefix + data.trim().replace(/\n/g, &#x27;\n&#x27; + prefix) + &#x27;\n&#x27;
		}
		return data
	},

	/**
	* Internal: Set output data
	* @private
	* @method outputData
	* @param {Object} data
	* @param {Object} [channel = &#x27;stdout&#x27;]
	* @param {Object} prefix
	*/
	outputData (data, channel = &#x27;stdout&#x27;, prefix) {
		if ( data.toString().trim().length !== 0 ) {
			if ( prefix ) {
				data = safeps.prefixData(data, prefix)
			}
			process[channel].write(data)
		}
		return null
	},


	// =================================
	// Spawn

	/**
	* Syncronised version of safeps.spawn. Will not return until the
	* child process has fully closed. Results can be returned
	* from the method call or via a passed callback. Even if
	* a callback is passed to spawnSync, the method will still
	* be syncronised with the child process and the callback will
	* only return after the child process has closed.
	*
	* Simple usage example:
	*
	*	var safeps = require(&#x27;safeps&#x27;);
	*	var command = [&#x27;npm&#x27;, &#x27;install&#x27;, &#x27;jade&#x27;, &#x27;--save&#x27;];
	*
	*	//a lot of the time you won&#x27;t need the opts argument
	*	var opts = {
	*		cwd: __dirname //this is actually pointless in a real application
	*	};
	*
	*	var result = safeps.spawnSync(command, opts);
	*
	*	console.log(result.error);
	*	console.log(result.status);
	*	console.log(result.signal);
	*	console.log(&quot;I&#x27;ve finished...&quot;);
	*
	* @method spawnSync
	* @param {Array|String} command
	* @param {Object} [opts]
	* @param {Boolean} [opts.safe] Whether to check the executable path.
	* @param {String} [opts.cwd] Current working directory of the child process
	* @param {Array|String} [opts.stdio] Child&#x27;s stdio configuration.
	* @param {Array} [opts.customFds] Deprecated File descriptors for the child to use for stdio.
	* @param {Object} [opts.env] Environment key-value pairs.
	* @param {Boolean} [opts.detached] The child will be a process group leader.
	* @param {Number} [opts.uid] Sets the user identity of the process.
	* @param {Number} [opts.gid] Sets the group identity of the process
	* @param {Function} [next] callback
	* @param {Error} next.error
	* @param {Stream} next.stdout out stream
	* @param {Stream} next.stderr error stream
	* @param {Number} next.status node.js exit code
	* @param {String} next.signal unix style signal such as SIGKILL or SIGHUP
	* @return {Object} {error, pid, output, stdout, stderr, status, signal}
	*/
	spawnSync (command, opts, next) {
		// Prepare
		[opts, next] = extractOptsAndCallback(opts, next)
		opts = safeps.prepareExecutableOptions(opts)
		opts.sync = true

		// If the command is a string, then convert it into an array
		if ( typeChecker.isString(command) ) {
			command = command.split(&#x27; &#x27;)
		}

		// Get correct executable path
		// Only possible if sync abilities are possible (node 0.12 and up) or if it is cached
		// Otherwise, don&#x27;t worry about it and output a warning to stderr
		if ( opts.safe ) {
			let wasSync = 0
			safeps.getExecPath(command[0], opts, function (err, execPath) {
				if ( err )  return
				command[0] = execPath
				wasSync = 1
			})
			if ( wasSync === 0 ) {
				process.stderr.write(&#x27;safeps.spawnSync: was unable to get the executable path synchronously&#x27;)
			}
		}

		// Spawn Synchronously
		const result = require(&#x27;child_process&#x27;).spawnSync(command[0], command.slice(1), opts)
		safeps.updateExecutableResult(result, opts)

		// Complete
		if ( next ) {
			next(result.error, result.stdout, result.stderr, result.status, result.signal)
		}
		else {
			return result
		}
	},

	/**
	* Wrapper around node&#x27;s spawn command for a cleaner, more robust and powerful API.
	* Launches a new process with the given command. Command line arguments are
	* part of the command parameter (unlike the node.js spawn). Command can be
	* an array of command line arguments or a command line string. Opts allows
	* additional options to be sent to the spawning action.
	*
	* Simple usage example:
	*
	* 	var safeps = require(&#x27;safeps&#x27;);
	*	var command = [&#x27;npm&#x27;, &#x27;install&#x27;,&#x27;jade&#x27;,&#x27;--save&#x27;];
	*
	*	//a lot of the time you won&#x27;t need the opts argument
	*	var opts = {
	*		cwd: __dirname //this is actually pointless in a real application
	*	}
	*	function myCallback(error, stdout, stderr, status, signal){
	*		console.log(error);
	*		console.log(status);
	*		console.log(signal);
	*		console.log(&quot;I&#x27;ve finished...&quot;);
	*	}
	*	safeps.spawn(command, opts, myCallback);
	*
	* @method spawn
	* @param {Array|String} command
	* @param {Object} [opts]
	* @param {Boolean} [opts.safe] Whether to check the executable path.
	* @param {String} [opts.cwd] Current working directory of the child process
	* @param {Array|String} [opts.stdio] Child&#x27;s stdio configuration.
	* @param {Array} [opts.customFds] Deprecated File descriptors for the child to use for stdio.
	* @param {Object} [opts.env] Environment key-value pairs.
	* @param {Boolean} [opts.detached] The child will be a process group leader.
	* @param {Number} [opts.uid] Sets the user identity of the process.
	* @param {Number} [opts.gid] Sets the group identity of the process.
	* @param {Function} next callback
	* @param {Error} next.error
	* @param {Stream} next.stdout out stream
	* @param {Stream} next.stderr error stream
	* @param {Number} next.status node.js exit code
	* @param {String} next.signal unix style signal such as SIGKILL or SIGHUP
	*/
	spawn (command, opts, next) {
		// Prepare
		[opts, next] = extractOptsAndCallback(opts, next)
		opts = safeps.prepareExecutableOptions(opts)

		// Check if we want sync instead
		if ( opts.sync ) {
			return safeps.spawnSync(command, opts, next)
		}

		// Patience
		safeps.openProcess(function (closeProcess) {
			// If the command is a string, then convert it into an array
			if ( typeChecker.isString(command) ) {
				command = command.split(&#x27; &#x27;)
			}

			// Prepare
			const result = {
				pid: null,
				stdout: null,
				stderr: null,
				output: null,
				error: null,
				status: null,
				signal: null
			}
			let exited = false

			// Tasks
			const tasks = new TaskGroup().done(function (err) {
				exited = true
				closeProcess()
				next(err || result.error, result.stdout, result.stderr, result.status, result.signal)
			})

			// Get correct executable path
			if ( opts.safe ) {
				tasks.addTask(function (complete) {
					safeps.getExecPath(command[0], opts, function (err, execPath) {
						if ( err )  return complete(err)
						command[0] = execPath
						complete()
					})
				})
			}

			// Spawn
			tasks.addTask(function (complete) {
				// Spawn
				result.pid = require(&#x27;child_process&#x27;).spawn(command[0], command.slice(1), opts)

				// Write if we want to
				// result.pid.stdin may be null of stdio is &#x27;inherit&#x27;
				if ( opts.stdin &amp;&amp; result.pid.stdin) {
					result.pid.stdin.write(opts.stdin)
					result.pid.stdin.end()
				}

				// Read if we want to by listening to the streams and updating our result variables
				if ( opts.read ) {
					// result.pid.stdout may be null of stdio is &#x27;inherit&#x27;
					if ( result.pid.stdout ) {
						result.pid.stdout.on(&#x27;data&#x27;, function (data) {
							if ( opts.output ) {
								safeps.outputData(data, &#x27;stdout&#x27;, opts.outputPrefix)
							}
							if ( result.stdout ) {
								result.stdout = Buffer.concat([result.stdout, data])
							}
							else {
								result.stdout = data
							}
						})
					}

					// result.pid.stderr may be null of stdio is &#x27;inherit&#x27;
					if ( result.pid.stderr ) {
						result.pid.stderr.on(&#x27;data&#x27;, function (data) {
							if ( opts.output) {
								safeps.outputData(data, &#x27;stderr&#x27;, opts.outputPrefix)
							}
							if ( result.stderr ) {
								result.stderr = Buffer.concat([result.stderr, data])
							}
							else {
								result.stderr = data
							}
						})
					}
				}

				// Wait
				result.pid.on(&#x27;close&#x27;, function (status, signal) {
					// Apply to local global
					result.status = status
					result.signal = signal

					// Check if we have already exited due to domains
					// as without this, then we will fire the completion callback twice
					// once for the domain error that will happen first
					// then again for the close error
					// if it happens the other way round, close, then error, we want to be alerted of that
					if ( exited === true )  return

					// Check result and complete
					opts.output = false
					safeps.updateExecutableResult(result, opts)
					return complete(result.error)
				})
			})

			// Run
			tasks.run()
		})

		// Chain
		return safeps
	},

	/**
	* Spawn multiple processes in the one method call.
 	* Launches new processes with the given array of commands.
	* Each item in the commands array represents a command parameter
	* sent to the safeps.spawn method, so each item can be a command line
	* string or an array of command line inputs. It is also possible
	* to pass a single command string and in this case calling
	* spawnMultiple will be effectively the same as calling safeps.spawn.
	* @method spawnMultiple
	* @param {Array|String} commands
	* @param {Object} [opts]
	* @param {Boolean} [opts.concurrency=1] Whether to spawn processes concurrently.
	* @param {String} opts.cwd Current working directory of the child process.
	* @param {Array|String} opts.stdio Child&#x27;s stdio configuration.
	* @param {Array} opts.customFds Deprecated File descriptors for the child to use for stdio.
	* @param {Object} opts.env Environment key-value pairs.
	* @param {Boolean} opts.detached The child will be a process group leader.
	* @param {Number} opts.uid Sets the user identity of the process.
	* @param {Number} opts.gid Sets the group identity of the process.
	* @param {Function} next callback
	* @param {Error} next.error
	* @param {Array} next.results array of spawn results
	* @param {Stream} next.results[i].stdout out stream
	* @param {Stream} next.results[i].stderr error stream
	* @param {Number} next.results[i].status node.js exit code
	* @param {String} next.results[i].signal unix style signal such as SIGKILL or SIGHUP
	*/
	spawnMultiple (commands, opts, next) {
		// Prepare
		[opts, next] = extractOptsAndCallback(opts, next)
		const results = []

		// Be synchronous by default
		if ( opts.concurrency == null )  opts.concurrency = 1

		// Make sure we send back the arguments
		const tasks = new TaskGroup().setConfig({concurrency: opts.concurrency}).done(function (err) {
			next(err, results)
		})

		// Prepare tasks
		if ( !typeChecker.isArray(commands) ) {
			commands = [commands]
		}

		// Add tasks
		commands.forEach(function (command) {
			tasks.addTask(function (complete) {
				safeps.spawn(command, opts, function (...args) {
					const err = args[0] || null
					results.push(args)
					complete(err)
				})
			})
		})

		// Run the tasks
		tasks.run()

		// Chain
		return safeps
	},


	// =================================
	// Exec

	/**
	* Syncronised version of safeps.exec. Runs a command in a shell and
	* buffers the output. Will not return until the
	* child process has fully closed. Results can be returned
	* from the method call or via a passed callback. Even if
	* a callback is passed to execSync, the method will still
	* be syncronised with the child process and the callback will
	* only return after the child process has closed.
	* Note:
	* Stdout and stderr should be Buffers but they are strings unless encoding:null
	* for now, nothing we should do, besides wait for joyent to reply
	* https://github.com/joyent/node/issues/5833#issuecomment-82189525.
	* @method execSync
	* @param {Object} command
	* @param {Object} [opts]
	* @param {Boolean} [opts.sync] true to execute sync rather than async
	* @param {String} [opts.cwd] Current working directory of the child process
	* @param {Object} [opts.env] Environment key-value pairs
	* @param {String} [opts.encoding=&#x27;utf8&#x27;]
	* @param {String} [opts.shell] Shell to execute the command with (Default: &#x27;/bin/sh&#x27; on UNIX, &#x27;cmd.exe&#x27; on Windows, The shell should understand the -c switch on UNIX or /s /c on Windows. On Windows, command line parsing should be compatible with cmd.exe.)
	* @param {Number} [opts.timeout=0]
	* @param {Number} [opts.maxBuffer=200*1024] Largest amount of data (in bytes) allowed on stdout or stderr - if exceeded child process is killed.
	* @param {String} [opts.killSignal=&#x27;SIGTERM&#x27;]
	* @param {Number} [opts.uid] Sets the user identity of the process.
	* @param {Number} [opts.gid] Sets the group identity of the process.
	* @param {Function} next
	* @param {Error} next.err
	* @param {Buffer|String} next.stdout out buffer
	* @param {Buffer|String} next.stderr error buffer
	* @return {Object} {error, stdout, stderr}
	*/
	execSync (command, opts, next) {
		// Prepare
		[opts, next] = extractOptsAndCallback(opts, next)
		opts = safeps.prepareExecutableOptions(opts)
		opts.sync = true

		// Output
		if ( opts.output === true &amp;&amp; !opts.outputPrefix ) {
			opts.stdio = &#x27;inherit&#x27;
			opts.output = null
		}

		// Spawn Synchronously
		let stdout, error
		try {
			stdout = require(&#x27;child_process&#x27;).execSync(command, opts)
		}
		catch ( err ) {
			error = err
		}

		// Check result
		const result = {error, stdout}
		safeps.updateExecutableResult(result, opts)

		// Complete
		if ( next ) {
			next(result.error, result.stdout, result.stderr)
		}
		else {
			return result
		}
	},

	/**
	* Wrapper around node&#x27;s exec command for a cleaner, more robust and powerful API.
	* Runs a command in a shell and buffers the output.
	* Note:
	* Stdout and stderr should be Buffers but they are strings unless encoding:null
	* for now, nothing we should do, besides wait for joyent to reply
	* https://github.com/joyent/node/issues/5833#issuecomment-82189525.
	* @method exec
	* @param {Object} command
	* @param {Object} [opts]
	* @param {Boolean} [opts.sync] true to execute sync rather than async
	* @param {String} [opts.cwd] Current working directory of the child process
	* @param {Object} [opts.env] Environment key-value pairs
	* @param {String} [opts.encoding=&#x27;utf8&#x27;]
	* @param {String} [opts.shell] Shell to execute the command with (Default: &#x27;/bin/sh&#x27; on UNIX, &#x27;cmd.exe&#x27; on Windows, The shell should understand the -c switch on UNIX or /s /c on Windows. On Windows, command line parsing should be compatible with cmd.exe.)
	* @param {Number} [opts.timeout=0]
	* @param {Number} [opts.maxBuffer=200*1024] Largest amount of data (in bytes) allowed on stdout or stderr - if exceeded child process is killed.
	* @param {String} [opts.killSignal=&#x27;SIGTERM&#x27;]
	* @param {Number} [opts.uid] Sets the user identity of the process.
	* @param {Number} [opts.gid] Sets the group identity of the process.
	* @param {Function} next
	* @param {Error} next.err
	* @param {Buffer|String} next.stdout out buffer
	* @param {Buffer|String} next.stderr error buffer
	*/
	exec (command, opts, next) {
		// Prepare
		[opts, next] = extractOptsAndCallback(opts, next)
		opts = safeps.prepareExecutableOptions(opts)

		// Check if we want sync instead
		if ( opts.sync ) {
			return safeps.execSync(command, opts, next)
		}

		// Patience
		safeps.openProcess(function (closeProcess) {
			// Output
			if ( opts.output === true &amp;&amp; !opts.outputPrefix ) {
				opts.stdio = &#x27;inherit&#x27;
				opts.output = null
			}

			// Execute command
			require(&#x27;child_process&#x27;).exec(command, opts, function (error, stdout, stderr) {
				// Complete the task
				closeProcess()

				// Prepare result
				const result = {error, stdout, stderr}
				safeps.updateExecutableResult(result, opts)

				// Complete
				return next(result.error, result.stdout, result.stderr)
			})
		})

		// Chain
		return safeps
	},

	/**
	* Exec multiple processes in the one method call.
 	* Launches new processes with the given array of commands.
	* Each item in the commands array represents a command parameter
	* sent to the safeps.exec method, so each item can be a command line
	* string or an array of command line inputs. It is also possible
	* to pass a single command string and in this case calling
	* execMultiple will be effectively the same as calling safeps.exec.
	* @method execMultiple
	* @param {Array|String} commands
	* @param {Object} [opts]
	* @param {Boolean} [opts.concurrency=1] Whether to exec processes concurrently.
	* @param {String} opts.cwd Current working directory of the child process.
	* @param {Array|String} opts.stdio Child&#x27;s stdio configuration.
	* @param {Array} opts.customFds Deprecated File descriptors for the child to use for stdio.
	* @param {Object} opts.env Environment key-value pairs.
	* @param {Boolean} opts.detached The child will be a process group leader.
	* @param {Number} opts.uid Sets the user identity of the process.
	* @param {Number} opts.gid Sets the group identity of the process.
	* @param {Function} next callback
	* @param {Error} next.error
	* @param {Array} next.results array of exec results
	* @param {Stream} next.results[i].stdout out buffer
	* @param {Stream} next.results[i].stderr error buffer
	*/
	execMultiple (commands, opts, next) {
		// Prepare
		[opts, next] = extractOptsAndCallback(opts, next)
		const results = []

		// Be synchronous by default
		if ( opts.concurrency == null )  opts.concurrency = 1

		// Make sure we send back the arguments
		const tasks = new TaskGroup().setConfig({concurrency: opts.concurrency}).done(function (err) {
			next(err, results)
		})

		// Prepare tasks
		if ( !typeChecker.isArray(commands) ) {
			commands = [commands]
		}

		// Add tasks
		commands.forEach(function (command) {
			tasks.addTask(function (complete) {
				safeps.exec(command, opts, function (...args) {
					const err = args[0] || null
					results.push(args)
					complete(err)
				})
			})
		})

		// Run the tasks
		tasks.run()

		// Chain
		return safeps
	},


	// =================================
	// Paths

	/**
	* Determine an executable path from
	* the passed array of possible file paths.
	* Called by getExecPath to find a path for
	* a given executable name.
	* @private
	* @method determineExecPath
	* @param {Array} possibleExecPaths string array of file paths
	* @param {Object} [opts]
	* @param {Boolean} [opts.sync] true to execute sync rather than async
	* @param {Function} next
	* @param {Error} next.err
	* @param {String} next.execPath
	*/
	determineExecPath (possibleExecPaths, opts, next) {
		// Prepare
		[opts, next] = extractOptsAndCallback(opts, next)
		let execPath = null

		// By default don&#x27;t be sync
		if ( opts.sync == null )  opts.sync = false

		// Group
		const tasks = new TaskGroup({sync: opts.sync}).done(function (err) {
			return next(err, execPath)
		})

		// Handle
		possibleExecPaths.forEach(function (possibleExecPath) {
			// Check if the path is invalid, if it is, skip it
			if ( !possibleExecPath )  return
			tasks.addTask(function (complete) {
				// Check if we have found the valid exec path earlier, if so, skip
				if ( execPath )  return complete()

				// Resolve the path as it may be a virtual or relative path
				possibleExecPath = pathUtil.resolve(possibleExecPath)

				// Check if the executeable exists
				safeps.isExecutable(possibleExecPath, opts, function (err, isExecutable) {
					if ( err || !isExecutable )  return complete()
					execPath = possibleExecPath
					return complete()
				})
			})
		})

		// Fire the tasks
		tasks.run()

		// Chain
		return safeps
	},

	/**
	* Get the system&#x27;s environment paths.
	* @method getEnvironmentPaths
	* @return {Array} string array of file paths
	*/
	getEnvironmentPaths () {
		// Fetch system include paths with the correct delimiter for the system
		const environmentPaths = process.env.PATH.split(pathUtil.delimiter)

		// Return
		return environmentPaths
	},

	/**
	* Get the possible paths for
	* the passed executable using the
	* standard environment paths. Basically,
	* get a list of places to look for the
	* executable. Only safe for non-Windows
	* systems.
	* @private
	* @method getStandardExecPaths
	* @param {String} execName
	* @return {Array} string array of file paths
	*/
	getStandardExecPaths (execName) {
		// Fetch
		let standardExecPaths = [process.cwd()].concat(safeps.getEnvironmentPaths())

		// Get the possible exec paths
		if ( execName ) {
			standardExecPaths = standardExecPaths.map(function (path) {
				return pathUtil.join(path, execName)
			})
		}

		// Return
		return standardExecPaths
	},

	/**
	* Get the possible paths for
	* the passed executable using the
	* standard environment paths. Basically,
	* get a list of places to look for the
	* executable. Makes allowances for Windows
	* executables possibly needing an extension
	* to ensure execution (.exe, .cmd, .bat).
	* @private
	* @method getStandardExecPaths
	* @param {String} execName
	* @return {Array} string array of file paths
	*/
	getPossibleExecPaths (execName) {
		let possibleExecPaths

		// Fetch available paths
		if ( isWindows &amp;&amp; execName.indexOf(&#x27;.&#x27;) === -1 ) {
			// we are for windows add the paths for .exe as well
			const standardExecPaths = safeps.getStandardExecPaths(execName)
			possibleExecPaths = []
			for ( const standardExecPath of standardExecPaths ) {
				possibleExecPaths.push(
					standardExecPath,
					standardExecPath + &#x27;.exe&#x27;,
					standardExecPath + &#x27;.cmd&#x27;,
					standardExecPath + &#x27;.bat&#x27;
				)
			}
		}
		else {
			// we are normal, try the paths
			possibleExecPaths = safeps.getStandardExecPaths(execName)
		}

		// Return
		return possibleExecPaths
	},

	/**
	* Cache of executable paths
	* @private
	* @property execPathCache
	*/
	execPathCache: {},

	/**
	* Given an executable name, search and find
	* its actual path. Will search the standard
	* file paths defined by the environment to
	* see if the executable is in any of those paths.
	* @method getExecPath
	* @param {Object} execName
	* @param {Object} [opts]
	* @param {Boolean} [opts.cache=true]
	* @param {Function} next
	* @param {Error} next.err
	* @param {String} next.foundPath path to the executable
	*/
	getExecPath (execName, opts, next) {
		// Prepare
		[opts, next] = extractOptsAndCallback(opts, next)

		// By default read from the cache and write to the cache
		if ( opts.cache == null )  opts.cache = true

		// Check for absolute path, as we would not be needed and would just currupt the output
		if ( execName.substr(0, 1) === &#x27;/&#x27; || execName.substr(1, 1) === &#x27;:&#x27; ) {
			next(null, execName)
			return safeps
		}

		// Prepare
		const execNameCapitalized = execName[0].toUpperCase() + execName.substr(1)
		const getExecMethodName = &#x27;get&#x27; + execNameCapitalized + &#x27;Path&#x27;

		// Check for special case
		if ( safeps[getExecMethodName] ) {
			return safeps[getExecMethodName](opts, next)
		}
		else {
			// Check for cache
			if ( opts.cache &amp;&amp; safeps.execPathCache[execName] ) {
				next(null, safeps.execPathCache[execName])
				return safeps
			}

			// Fetch possible exec paths
			const possibleExecPaths = safeps.getPossibleExecPaths(execName)

			// Forward onto determineExecPath
			// Which will determine which path it is out of the possible paths
			safeps.determineExecPath(possibleExecPaths, opts, function (err, execPath) {
				if ( err ) {
					next(err)
				}
				else if ( !execPath ) {
					err = new Error(&#x60;Could not locate the ${execName} executable path&#x60;)
					next(err)
				}
				else {
					// Success, write the result to cache and send to our callback
					if ( opts.cache )  safeps.execPathCache[execName] = execPath
					return next(null, execPath)
				}
			})
		}

		// Chain
		return safeps
	},

	/**
	* Get home path. Returns the user&#x27;s home directory.
	* Based upon home function from: https://github.com/isaacs/osenv
	* @method getHomePath
	* @param {Object} [opts]
	* @param {Object} [opts.cache=true]
	* @param {Function} next
	* @param {Error} next.err
	* @param {String} next.homePath
	*/
	getHomePath (opts, next) {
		// Prepare
		[opts, next] = extractOptsAndCallback(opts, next)

		// By default read from the cache and write to the cache
		if ( opts.cache == null )  opts.cache = true

		// Cached
		if ( opts.cache &amp;&amp; safeps.cachedHomePath ) {
			next(null, safeps.cachedHomePath)
			return safeps
		}

		// Fetch
		const homePath = process.env.USERPROFILE || process.env.HOME || null

		// Success, write the result to cache and send to our callback
		if ( opts.cache )  safeps.cachedHomePath = homePath
		next(null, homePath)

		// Chain
		return safeps
	},

	/**
	* Path to the evironment&#x27;s temporary directory.
	* Based upon tmpdir function from: https://github.com/isaacs/osenv
	* @method getTmpPath
	* @param {Object} [opts]
	* @param {Object} [opts.cache=true]
	* @param {Error} next.err
	* @param {String} next.tmpPath
	*/
	getTmpPath (opts, next) {
		// Prepare
		[opts, next] = extractOptsAndCallback(opts, next)

		// By default read from the cache and write to the cache
		if ( opts.cache == null )  opts.cache = true

		// Cached
		if ( opts.cache &amp;&amp; safeps.cachedTmpPath ) {
			next(null, safeps.cachedTmpPath)
			return safeps
		}

		// Prepare
		const tmpDirName = isWindows ? &#x27;temp&#x27; : &#x27;tmp&#x27;

		// Try the OS environment temp path
		let tmpPath = process.env.TMPDIR || process.env.TMP || process.env.TEMP || null

		// Fallback
		if ( !tmpPath ) {
			// Try the user directory temp path
			safeps.getHomePath(opts, function (err, homePath) {
				if ( err )  return next(err)
				tmpPath = pathUtil.resolve(homePath, tmpDirName)

				// Fallback
				if ( !tmpPath ) {
					// Try the system temp path
					// @TODO perhaps we should check if we have write access to this path
					tmpPath = isWindows
						? pathUtil.resolve(process.env.windir || &#x27;C:\\Windows&#x27;, tmpDirName)
						: &#x27;/tmp&#x27;
				}
			})
		}

		// Check if we couldn&#x27;t find it, we should always be able to find it
		if ( !tmpPath ) {
			const err = new Error(&quot;Wan&#x27;t able to find a temporary path&quot;)
			next(err)
		}

		// Success, write the result to cache and send to our callback
		if ( opts.cache )  safeps.cachedTmpPath = tmpPath
		next(null, tmpPath)

		// Chain
		return safeps
	},

	/**
	* Path to the evironment&#x27;s GIT directory.
	* As &#x27;git&#x27; is not always available in the environment path, we should check
	* common path locations and if we find one that works, then we should use it.
	* @method getGitPath
	* @param {Object} [opts]
	* @param {Object} [opts.cache=true]
	* @param {Error} next.err
	* @param {String} next.gitPath
	*/
	getGitPath (opts, next) {
		// Prepare
		[opts, next] = extractOptsAndCallback(opts, next)

		// By default read from the cache and write to the cache
		if ( opts.cache == null )  opts.cache = true

		// Cached
		if ( opts.cache &amp;&amp; safeps.cachedGitPath ) {
			next(null, safeps.cachedGitPath)
			return safeps
		}

		// Prepare
		const execName = isWindows ? &#x27;git.exe&#x27; : &#x27;git&#x27;
		const possibleExecPaths = []

		// Add environment paths
		if ( process.env.GIT_PATH )  possibleExecPaths.push(process.env.GIT_PATH)
		if ( process.env.GITPATH  )  possibleExecPaths.push(process.env.GITPATH)

		// Add standard paths
		possibleExecPaths.push(...safeps.getStandardExecPaths(execName))

		// Add custom paths
		if ( isWindows ) {
			possibleExecPaths.push(
				&#x60;/Program Files (x64)/Git/bin/${execName}&#x60;,
				&#x60;/Program Files (x86)/Git/bin/${execName}&#x60;,
				&#x60;/Program Files/Git/bin/${execName}&#x60;
			)
		}
		else {
			possibleExecPaths.push(
				&#x60;/usr/local/bin/${execName}&#x60;,
				&#x60;/usr/bin/${execName}&#x60;,
				&#x60;~/bin/${execName}&#x60;
			)
		}

		// Determine the right path
		safeps.determineExecPath(possibleExecPaths, opts, function (err, execPath) {
			if ( err ) {
				next(err)
			}
			else if ( !execPath ) {
				err = new Error(&#x27;Could not locate git binary&#x27;)
				next(err)
			}
			else {
				// Success, write the result to cache and send to our callback
				if ( opts.cache )  safeps.cachedGitPath = execPath
				next(null, execPath)
			}
		})

		// Chain
		return safeps
	},

	/**
	* Path to the evironment&#x27;s Node directory.
	* As &#x27;node&#x27; is not always available in the environment path, we should check
	* common path locations and if we find one that works, then we should use it
	* @method getNodePath
	* @param {Object} [opts]
	* @param {Object} [opts.cache=true]
	* @param {Error} next.err
	* @param {String} next.nodePath
	*/
	getNodePath (opts, next) {
		// Prepare
		[opts, next] = extractOptsAndCallback(opts, next)

		// By default read from the cache and write to the cache
		if ( opts.cache == null )  opts.cache = true

		// Cached
		if ( opts.cache &amp;&amp; safeps.cachedNodePath ) {
			next(null, safeps.cachedNodePath)
			return safeps
		}

		// Prepare
		const execName = isWindows ? &#x27;node.exe&#x27; : &#x27;node&#x27;
		const possibleExecPaths = []

		// Add environment paths
		if ( process.env.NODE_PATH )                  possibleExecPaths.push(process.env.NODE_PATH)
		if ( process.env.NODEPATH )                   possibleExecPaths.push(process.env.NODEPATH)
		if ( /node(.exe)?$/.test(process.execPath) )  possibleExecPaths.push(process.execPath)

		// Add standard paths
		possibleExecPaths.push(...safeps.getStandardExecPaths(execName))

		// Add custom paths
		if ( isWindows ) {
			possibleExecPaths.push(
				&#x60;/Program Files (x64)/nodejs/${execName}&#x60;,
				&#x60;/Program Files (x86)/nodejs/${execName}&#x60;,
				&#x60;/Program Files/nodejs/${execName}&#x60;
			)
		}
		else {
			possibleExecPaths.push(
				&#x60;/usr/local/bin/${execName}&#x60;,
				&#x60;/usr/bin/${execName}&#x60;,
				&#x60;~/bin/${execName}&#x60;  // User and Heroku
			)
		}

		// Determine the right path
		safeps.determineExecPath(possibleExecPaths, opts, function (err, execPath) {
			if ( err ) {
				next(err)
			}
			else if ( !execPath ) {
				err = new Error(&#x27;Could not locate node binary&#x27;)
				next(err)
			}
			else {
				// Success, write the result to cache and send to our callback
				if ( opts.cache )  safeps.cachedNodePath = execPath
				next(null, execPath)
			}
		})

		// Chain
		return safeps
	},

	/**
	* Path to the evironment&#x27;s NPM directory.
	* As &#x27;npm&#x27; is not always available in the environment path, we should check
	* common path locations and if we find one that works, then we should use it
	* @method getNpmPath
	* @param {Object} [opts]
	* @param {Object} [opts.cache=true]
	* @param {Error} next.err
	* @param {String} next.npmPath
	*/
	getNpmPath (opts, next) {
		// Prepare
		[opts, next] = extractOptsAndCallback(opts, next)

		// By default read from the cache and write to the cache
		if ( opts.cache == null )  opts.cache = true

		// Cached
		if ( opts.cache &amp;&amp; safeps.cachedNpmPath ) {
			next(null, safeps.cachedNpmPath)
			return safeps
		}

		// Prepare
		const execName = isWindows ? &#x27;npm.cmd&#x27; : &#x27;npm&#x27;
		const possibleExecPaths = []

		// Add environment paths
		if ( process.env.NPM_PATH )                   possibleExecPaths.push(process.env.NPM_PATH)
		if ( process.env.NPMPATH )                    possibleExecPaths.push(process.env.NPMPATH)
		if ( /node(.exe)?$/.test(process.execPath) )  possibleExecPaths.push(process.execPath.replace(/node(.exe)?$/, execName))

		// Add standard paths
		possibleExecPaths.push(...safeps.getStandardExecPaths(execName))

		// Add custom paths
		if ( isWindows ) {
			possibleExecPaths.push(
				&#x60;/Program Files (x64)/nodejs/${execName}&#x60;,
				&#x60;/Program Files (x86)/nodejs/${execName}&#x60;,
				&#x60;/Program Files/nodejs/${execName}&#x60;
			)
		}
		else {
			possibleExecPaths.push(
				&#x60;/usr/local/bin/${execName}&#x60;,
				&#x60;/usr/bin/${execName}&#x60;,
				&#x60;~/node_modules/.bin/${execName}&#x60; // User and Heroku
			)
		}

		// Determine the right path
		safeps.determineExecPath(possibleExecPaths, opts, function (err, execPath) {
			if ( err ) {
				next(err)
			}
			else if ( !execPath ) {
				err = new Error(&#x27;Could not locate npm binary&#x27;)
				next(err)
			}
			else {
				// Success, write the result to cache and send to our callback
				if ( opts.cache )  safeps.cachedNpmPath = execPath
				next(null, execPath)
			}
		})

		// Chain
		return safeps
	},


	// =================================
	// Special Commands
	// @TODO These should be abstracted out into their own packages

	/**
	* Initialize a git Repository.
	* Requires internet access.
	* @method initGitRepo
	* @param {Object} opts
	* @param {String} opts.path path to initiate local repository
	* @param {String} [opts.remote=&#x27;origin&#x27;]
	* @param {String} opts.url url to git remote repository
	* @param {String} [opts.branch=&#x27;master&#x27;]
	* @param {String} opts.log
	* @param {String} opts.output
	* @param {String} [opts.cwd=process.cwd()] Current working directory of the child process.
	* @param {Function} next
	* @param {Error} next.err
	* @param {Array} next.results array of spawn results
	* @param {Stream} next.results[i].stdout out stream
	* @param {Stream} next.results[i].stderr error stream
	* @param {Number} next.results[i].status node.js exit code
	* @param {String} next.results[i].signal unix style signal such as SIGKILL or SIGHUP
	*/
	initGitRepo (opts, next) {
		// Extract
		[opts, next] = extractOptsAndCallback(opts, next)

		// Defaults
		if ( !opts.cwd )     opts.cwd = process.cwd()
		if ( !opts.remote )  opts.remote = &#x27;origin&#x27;
		if ( !opts.branch )  opts.branch = &#x27;master&#x27;

		// Prepare commands
		const commands = []
		commands.push([&#x27;git&#x27;, &#x27;init&#x27;])
		if ( opts.url ) {
			commands.push([&#x27;git&#x27;, &#x27;remote&#x27;, &#x27;add&#x27;, opts.remote, opts.url])
		}
		commands.push([&#x27;git&#x27;, &#x27;fetch&#x27;, opts.remote])
		commands.push([&#x27;git&#x27;, &#x27;pull&#x27;, opts.remote, opts.branch])
		commands.push([&#x27;git&#x27;, &#x27;submodule&#x27;, &#x27;init&#x27;])
		commands.push([&#x27;git&#x27;, &#x27;submodule&#x27;, &#x27;update&#x27;, &#x27;--recursive&#x27;])

		// Perform commands
		safeps.spawnMultiple(commands, opts, next)

		// Chain
		return safeps
	},

	/**
	* Pull from a git repository if it already exists
	* on the file system else initialize  new Git repository.
	* Requires internet access.
	* @method initOrPullGitRepo
	* @param {Object} opts
	* @param {String} opts.path path to local repository
	* @param {String} [opts.remote=&#x27;origin&#x27;]
	* @param {String} opts.url url to git remote repository
	* @param {String} [opts.branch=&#x27;master&#x27;]
	* @param {String} opts.log
	* @param {String} opts.output
	* @param {String} [opts.cwd=process.cwd()] Current working directory of the child process.
	* @param {Function} next
	* @param {Error} next.err
	* @param {Array} next.results array of spawn results
	* @param {Stream} next.results[i].stdout out stream
	* @param {Stream} next.results[i].stderr error stream
	* @param {Number} next.results[i].status node.js exit code
	* @param {String} next.results[i].signal unix style signal such as SIGKILL or SIGHUP
	*/
	initOrPullGitRepo (opts, next) {
		// Extract
		[opts, next] = extractOptsAndCallback(opts, next)

		// Defaults
		if ( !opts.cwd )     opts.cwd = process.cwd()
		if ( !opts.remote )  opts.remote = &#x27;origin&#x27;
		if ( !opts.branch )  opts.branch = &#x27;master&#x27;

		// Check if it exists
		safefs.ensurePath(opts.cwd, function (err, exists) {
			if ( err ) {
				next(err)
			}
			else if ( exists ) {
				safeps.spawn([&#x27;git&#x27;, &#x27;pull&#x27;, opts.remote, opts.branch], opts, function (err, ...result) {
					next(err, &#x27;pull&#x27;, result)
				})
			}
			else {
				safeps.initGitRepo(opts, function (err, result) {
					next(err, &#x27;init&#x27;, result)
				})
			}
		})

		// Chain
		return safeps
	},

	/**
	* Init Node Modules with cross platform support
	* supports linux, heroku, osx, windows
	* @method initNodeModules
	* @param {Object} opts
	* @param {Function} next
	* @param {Object} next.err
	* @param {Stream} next.stdout out stream
	* @param {Stream} next.stderr error stream
	* @param {Number} next.status node.js exit code
	* @param {String} next.signal unix style signal such as SIGKILL or SIGHUP
	*/
	initNodeModules (opts, next) {
		// Prepare
		[opts, next] = extractOptsAndCallback(opts, next)

		// Defaults
		if ( !opts.cwd )           opts.cwd = process.cwd()
		if ( opts.args == null )   opts.args = []
		if ( opts.force == null )  opts.force = false

		// Paths
		const packageJsonPath = pathUtil.join(opts.cwd, &#x27;package.json&#x27;)
		const nodeModulesPath = pathUtil.join(opts.cwd, &#x27;node_modules&#x27;)

		// Split this commands into parts
		function partTwo () {
			// If there is no package.json file, then we can&#x27;t do anything
			safefs.exists(packageJsonPath, function (exists) {
				if ( !exists )  return next()

				// Prepare command
				const command = [&#x27;npm&#x27;, &#x27;install&#x27;].concat(opts.args)

				// Execute npm install inside the pugin directory
				safeps.spawn(command, opts, next)
			})
		}
		function partOne () {
			// If we are not forcing, then skip if node_modules already exists
			if ( !opts.force ) {
				safefs.exists(nodeModulesPath, function (exists) {
					if ( exists )  return next()
					partTwo()
				})
			}
			else {
				partTwo()
			}
		}

		// Run the first part
		partOne()

		// Chain
		return safeps
	},

	/**
	* Spawn Node Modules with cross platform support
	* supports linux, heroku, osx, windows
	* spawnNodeModule(name:string, args:array, opts:object, next:function)
	* Better than https://github.com/mafintosh/npm-execspawn as it uses safeps
	* @method spawnNodeModule
	* @param {String} name
	* @param {Array} args
	* @param {Object} opts
	* @param {String} opts.name name of node module
	* @param {String} [opts.cwd=process.cwd()] Current working directory of the child process.
	* @param {Function} next
	* @param {Object} next.err
	* @param {Stream} next.stdout out stream
	* @param {Stream} next.stderr error stream
	* @param {Number} next.status node.js exit code
	* @param {String} next.signal unix style signal such as SIGKILL or SIGHUP
	*/
	spawnNodeModule (...args) {
		// Prepare
		const opts = {cwd: process.cwd()}
		let next

		// Extract options
		for ( const arg of args ) {
			const type = typeof arg
			if ( Array.isArray(arg) ) {
				opts.args = arg
			}
			else if ( type === &#x27;object&#x27; ) {
				if ( arg.next ) {
					next = arg.next
					arg.next = null
				}
				for ( const key of Object.keys(arg) ) {
					opts[key] = arg[key]
				}
			}
			else if ( type === &#x27;function&#x27; ) {
				next = arg
			}
			else if ( type === &#x27;string&#x27; ) {
				opts.name = arg
			}
		}

		// Command
		let command
		if ( opts.name ) {
			command = [opts.name].concat(opts.args || [])
			opts.name = null
		}
		else {
			command = [].concat(opts.args || [])
		}

		// Clean up
		opts.args = null

		// Paths
		command[0] = pathUtil.join(opts.cwd, &#x27;node_modules&#x27;, &#x27;.bin&#x27;, command[0])

		// Spawn
		safeps.spawn(command, opts, next)

		// Chain
		return safeps
	}
}

// =====================================
// Export

module.exports = safeps

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
